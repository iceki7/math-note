
# 编码：
# 将所有可能的信息组合映射到一个装备了距离的空间上，
# 且使得空间中任意两个代表信息的元素的距离
# （存在一些不代表信息的元素，那些就是用来证明信息有错的）足够大

# 如果出错半径的圆都不相交，就可以纠错。反之只能证明有错，但不能找出来。

#汉明码映射到的这个空间就是4×4的01串



##
#Hamming：
#行、列校验码J、K，内容N  （11，5）
# 总校验码S：判断错误数是0/1/2个。
    #如果是1个：
        # N：J、K都报错，且它们分别锁定了一个行（列）。
        # J：K不报错。J报错，所以错的就是声称有错的那个。
        # 都不报错：S自己错了。
    #如果是0/2个：
        #JJ: K不报错。至少有一个J报错。
        #JK：至少有一个J报错。
        #JN：K报错,且能锁定一个列。
        #NN1：如果都在同一列，那么对于那些不同时扫描这两行的J，至少会有一个J报错。K不报错。
        #NN2:如果不在同一行同一列，那么根据NN1，至少有一个J和K报错。
        #所以，如果是2个，虽然无法纠正，但至少有一个报错。没有报错说明是0个。

# >=3个错误无法处理。

#扩展到16*16的大小，是分块高效还是合在一块里高效?
    #块越大，出现多处错误的可能性就增大。但是可以节省校验位的使用。
    #正确概率P。错1个代价L1，错2个代价L2，错3个及以上的代价L3。校验位个数K.
    #分块x*x
    #优化W= P^(x2-1)*(1-P)* L1 +
    #       P^(x2-2)*(1-P)^2 * L2 +
    #       P^(x2-3)*(1-P)^3 * L3 
    #       +Lk * K
    #       K=(2 logx + 1)*(C/x2)    C是字符个数，假设已经补齐到了2的幂次个  

#矫错的过程有点像卷积，

#如果信息多次转发，错误可能累积。但是1个错误可以修正。
#假设要转发m次，每个信道上无错概率r，错一个的概率是q。
#那么所有信道发送次数的期望是，矫正次数的期望：
#中间信道的发送次数期望E，接收次数期望E',E=E'
# E=(r+q)+(1-r+q)*2
#