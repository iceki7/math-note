一个信源，它不断产生信息，设为一个随机变量。为这个变量进行编码，使得编码后的长度尽可能小。

如果是等长显然不合算。概率更大的分配也许更短的码长更好。问题是理论上能短到什么程度。

这个长度是概率性的。比如最频繁的消息编码为0，最稀有的消息编码为100，那如果一段时间内总是来最稀有的消息，那么这个方法一样效率不佳，所以长度是概率性的。
所以，我们求的是如果现在传来一个消息，它的长度的期望E(L)。


一个办法就是：概率越大，分配的码长越短。而且任何码都不是另一个码的前缀。
这样我们的编码可以看成是一颗二叉树，任何一个码字都是从根到叶子的一条路径。
现在的问题是，1、给出分布X，能不能想出一个算法，直接求出E(L)。
例如，假设X={0.6，0.25，0.15}，那怎么求码字？
0.6的那份对应的码字是0，其余两份对应的码字分别是10，11即可。

这是因为0.6出现的概率最大，而两个数如果要与另外两个数加权相乘再相加，
设X的取值概率y>x，码长m>n时，则平均码长：ym+xn>yn+xm,（*） 所以更大的概率与更小的码字相配是更好的。
虽然这个等式只对变量结果只有2个时成立，但如果随机变量取更多的值时呢？这时b就不是指代一个随机变量取值了，而是某些取值，同样的n也不是指码长，而是某些码长的期望。
比如X=0.1,0.2,0.3,0.4。
假设总共有k个取值，码长最长为logK，此时就是等长编码了。所以，无非就是00，01，10，11，我们能不能找到一个码长期望E(L)<2？
现在假设把用来给0.1那份编码的一个比特挪走用来给其他的信息编码，就是在树上取走一个叶子，放到其他的分叉去。但是只挪这一个叶子肯定不行，因为出现了前缀。所以这棵树还可以再摆弄摆弄。
所以新的树只有一种（不考虑0和1交换的情形，只考虑长度），那就是R-A R-B A-C A-D D-E D-F
假设已经选定了这棵树用作编码，那么我们的任务就是把每一个分支分给一个概率，并且希望它的期望<2。

我们不知道正确的排列是什么。所以先随便分配一个编码方案C0，C0(0.1，0.2，0.3，0.4)对应的码字分别是（以叶子表示）C,E,F,B
然后，我们尝试交换其中两个编码所对应的消息，看能否让E(L)减小（根据前面的等式可以判断交换后码长会不会变小），不断执行这个操作。
经过若干次交换直到再也不能让E(L)减小后，如果在概率空间和对应的码长空间中分别取两个元素x<y，L(y)=m,L(x)=n
则一定有关系m > n。所以，0.1，0.2，0.3，0.4对应的码长分别为1，2，3，3。
所以在这棵树T下的最佳方案，就是把码长逆序排列。


问题简化为该选择哪一棵树。
和前一个问题的考虑方法类似，我们尝试把一棵树通过变动修改为另一棵树，检查这个过程中E(L)是增大了，还是减小了。



这是因为，假设它不是最优的，那么在最优方法里，0.4对应的码字长度就不是1，那么根据前面的等式，
此外，另一个想法是，我们不编码单个出现的信息（ABCD），而是根据多个信息的组合的概率进行编码（AB AC AD 等等）
还是先编码单个信息吧。







比如消息概率从小到大依次是a,b,1-a-b
那么如果采用