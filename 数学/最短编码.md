一个信源，它不断产生信息，设为一个随机变量。为这个变量进行编码，使得编码后的长度尽可能小。

如果是等长显然不合算。概率更大的分配也许更短的码长更好。问题是理论上能短到什么程度。

这个长度是概率性的。比如最频繁的消息编码为0，最稀有的消息编码为100，那如果一段时间内总是来最稀有的消息，那么这个方法一样效率不佳，所以长度是概率性的。
所以，我们求的是如果现在传来一个消息，它的长度的期望E(L)。
一个办法就是：概率越大，分配的码长越短。而且任何码都不是另一个码的前缀。
这样我们的编码可以看成是一颗二叉树，任何一个码字都是从根到叶子的一条路径。
现在的问题是，1、给出分布X，能不能想出一个算法，直接求出E(L)。
例如，假设X是0.6，0.25，0.15，那怎么求码字？
0.6的那份对应的码字是0，其余两份对应的码字分别是10，11即可。

这是因为0.6出现的概率最大，而两个数如果要与另外两个数加权相乘再相加，
而当b>a,m>n时，bm+an>bn+am, 所以更大的概率与更小的码字相配是更好的。
虽然这个等式只对变量结果只有2个时成立，但如果随机变量取更多的值时呢？这时b就不是指代一个随机变量取值了，而是某些取值，同样的n也不是指码长，而是某些码长的期望。
比如X=0.1,0.2,0.3,0.4。
假设总共有k个取值，码长最长为logK，此时就是等长编码了。所以，无非就是00，01，10，11，我们能不能找到一个码长期望E(L)<2？
现在假设把用来给0.1那份编码的一个比特挪走用来给其他的信息编码，就是在树上取走一个叶子，放到其他的分叉去。但是只挪这一个叶子肯定不行，因为出现了前缀。所以这棵树还可以再摆弄摆弄。
所以新的树只有一种（不考虑0和1交换的情形，只考虑长度），那就是R-A R-B A-C A-D D-E D-F
分支A的编码长度是1，另一个分支的长度【起码是2】，所以根据前边那个等式，假设已经选定了这棵树用作编码，那么给把概率重新写成0.4，0.6，我们的任务只是要选出谁使用码字R-A。根据前边的等式，
这是因为，假设它不是最优的，那么在最优方法里，0.4对应的码字长度就不是1，那么根据前面的等式，
此外，另一个想法是，我们不编码单个出现的信息（ABCD），而是根据多个信息的组合的概率进行编码（AB AC AD 等等）
还是先编码单个信息吧。







比如消息概率从小到大依次是a,b,1-a-b
那么如果采用