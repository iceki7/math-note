定义部分和为某个序列$a_n$的前n项：
$$
s_n=\sum_i^n a_i
$$
级数是部分和的极限，即$\lim_{n\rightarrow \infty}s_n$

**关于单调有界必收敛的一点疑问**
充分：单调有界K的$s_n$数列在【实数域】上是收敛的。

通常的证明会用到确界原理，不过这里想给出另一点个人的理解。

考虑如下一个思想实验：
假设它单调递增，且有某个上界k。
那么，如果我们要求出它的极限l，可能无法一下子得到这个具体的实数。
但是，这个实数的前任意多位总是可以被确定下来。
例如，k=5，如果我们测试 $s_5$=4.5，那么我们知道5=>l>4.5
实际上，我们不需要考虑这个极限数字的精确值是多少，只要先考虑十分位，也就是4.x，要确定r是大于4.x还是小于4.x总是可行的。
通过不断地测试s_n，我们可能会发现它sk=4.6，因此，5=>l>4.6。
但是，接下来经过很多次的测试，都没有发现s_n>=4.7的情况，实际上如果光靠一个个验算，我们当然无法永远知道它是否会到达4.7，或者永远小于4.7，因为我们的验算时间可能大大超出了我们的寿命。
但是，如果分析s_n的表达式，可以用某种未知的方法M得到这个结果，即存在，或者不存在n，使得sn>=4.7，那么我们知道这个数列最终的前两位肯定是确定下来了，如果存在那么一个n，那么数列之后的值的十分位就是789，如果不存在，那么数列之后的十分位的值就永远是6.
对于十分位的值是789，也可以用这个方法进行分析，总之，这个值能否达到4.7,4.8,4.9,或者一直停留在小于4.7，是可以确定的。
在确定里十分位以后，用同样的方式分析百分位即可。
例如，假设分析之后发现，这个数列的值会在n=100时达到sn=4.8，但用方法M可以证明它永远不会达到sn=4.9，
那么，我们知道极限4.8 < A<= 4.9，A的个位被确定了下来。
之后分析百分位时，在n=150时，达到sn=4.85,但它永远不会到达4.88
那么，我们知道极限4.8 < A <=4.88，A的十分位被确定了下来。
通过这个方法，也就逼近了极限A这个实数。

当然了，前提是确实有那个方法M，即对任意给定的常数C，M(C)告诉我们sn能否达到C。
如果这是一个黑箱函数，我们只能对它进行一个个的枚举（哪怕是算力无限强大的枚举），即输入一个值返回一个值，
但没有那种方法M，那么说它有极限A，就变得毫无意义了，因为我们【不一定】能在有限步骤内判断它是否能达到4.7。
反过来说，只要有一个算法M，能给定一个流程，让我们在有限的步骤内判断sn能否达到C（哪怕那实际运算时间长的不可救药），
但只要是有限个步骤，定义A就是有意义的。
因此，引入一个前提：
【前提F】如果对于f(x)，任给一个常数C，我们都可以保证在有限时间内能够判断是否存在x使得f(x)>C。
那么此时定义f(x)的极限显然才有意义。注意，这里的【有限时间】是指在原理上可行，而非一定是算力上可行，但它和无限时间毕竟不是一回事，例如枚举就是无限时间的。
如果符合这个前提，那么我们可以刻画出f的上界构成的集合B。（对于任意一个实数r，可以在有限时间内判断它是否属于B），此时用上述方法，就可以构造出B集合中的最小值，也即上确界，也就是说，此时才满足单调有界必收敛。

**性质**

1、若 $\sum^{\infty} |a_n|$ 收敛，则 $\sum^{\infty} a_n $收敛。

证明的思路：考虑使用级数的加和的性质去证。

因为 $sum^{\infty}b_n=|a_n|-a_n $ 只是取了 $\sum^{\infty} |a_n|$ 中的一部分项。
因为我们已知|a_n|收敛，故上述的前提F是成立的，即总能判断任意实数C是否满足存在N，使得|a_N|>C。
这在原则上可行，只要比较它的极限值A和C即可。因此，对于b_n，前提F也是成立的，同时，它也满足单调递增且有界，因此b_n收敛。
